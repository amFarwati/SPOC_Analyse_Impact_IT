{"ast":null,"code":"'use strict';\n\nconst {\n  Transform\n} = require('stream');\nmodule.exports = {\n  download(response, emitter, downloadBodySize) {\n    let downloaded = 0;\n    return new Transform({\n      transform(chunk, encoding, callback) {\n        downloaded += chunk.length;\n        const percent = downloadBodySize ? downloaded / downloadBodySize : 0;\n\n        // Let `flush()` be responsible for emitting the last event\n        if (percent < 1) {\n          emitter.emit('downloadProgress', {\n            percent,\n            transferred: downloaded,\n            total: downloadBodySize\n          });\n        }\n        callback(null, chunk);\n      },\n      flush(callback) {\n        emitter.emit('downloadProgress', {\n          percent: 1,\n          transferred: downloaded,\n          total: downloadBodySize\n        });\n        callback();\n      }\n    });\n  },\n  upload(request, emitter, uploadBodySize) {\n    const uploadEventFrequency = 150;\n    let uploaded = 0;\n    let progressInterval;\n    emitter.emit('uploadProgress', {\n      percent: 0,\n      transferred: 0,\n      total: uploadBodySize\n    });\n    request.once('error', () => {\n      clearInterval(progressInterval);\n    });\n    request.once('response', () => {\n      clearInterval(progressInterval);\n      emitter.emit('uploadProgress', {\n        percent: 1,\n        transferred: uploaded,\n        total: uploadBodySize\n      });\n    });\n    request.once('socket', socket => {\n      const onSocketConnect = () => {\n        progressInterval = setInterval(() => {\n          const lastUploaded = uploaded;\n          /* istanbul ignore next: see #490 (occurs randomly!) */\n          const headersSize = request._header ? Buffer.byteLength(request._header) : 0;\n          uploaded = socket.bytesWritten - headersSize;\n\n          // Don't emit events with unchanged progress and\n          // prevent last event from being emitted, because\n          // it's emitted when `response` is emitted\n          if (uploaded === lastUploaded || uploaded === uploadBodySize) {\n            return;\n          }\n          emitter.emit('uploadProgress', {\n            percent: uploadBodySize ? uploaded / uploadBodySize : 0,\n            transferred: uploaded,\n            total: uploadBodySize\n          });\n        }, uploadEventFrequency);\n      };\n\n      /* istanbul ignore next: hard to test */\n      if (socket.connecting) {\n        socket.once('connect', onSocketConnect);\n      } else if (socket.writable) {\n        // The socket is being reused from pool,\n        // so the connect event will not be emitted\n        onSocketConnect();\n      }\n    });\n  }\n};","map":{"version":3,"names":["Transform","require","module","exports","download","response","emitter","downloadBodySize","downloaded","transform","chunk","encoding","callback","length","percent","emit","transferred","total","flush","upload","request","uploadBodySize","uploadEventFrequency","uploaded","progressInterval","once","clearInterval","socket","onSocketConnect","setInterval","lastUploaded","headersSize","_header","Buffer","byteLength","bytesWritten","connecting","writable"],"sources":["/home/amfarwati/Documents/SPOC_Analyse_Impact_IT/v_0.1/client/node_modules/got/source/progress.js"],"sourcesContent":["'use strict';\nconst {Transform} = require('stream');\n\nmodule.exports = {\n\tdownload(response, emitter, downloadBodySize) {\n\t\tlet downloaded = 0;\n\n\t\treturn new Transform({\n\t\t\ttransform(chunk, encoding, callback) {\n\t\t\t\tdownloaded += chunk.length;\n\n\t\t\t\tconst percent = downloadBodySize ? downloaded / downloadBodySize : 0;\n\n\t\t\t\t// Let `flush()` be responsible for emitting the last event\n\t\t\t\tif (percent < 1) {\n\t\t\t\t\temitter.emit('downloadProgress', {\n\t\t\t\t\t\tpercent,\n\t\t\t\t\t\ttransferred: downloaded,\n\t\t\t\t\t\ttotal: downloadBodySize\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tcallback(null, chunk);\n\t\t\t},\n\n\t\t\tflush(callback) {\n\t\t\t\temitter.emit('downloadProgress', {\n\t\t\t\t\tpercent: 1,\n\t\t\t\t\ttransferred: downloaded,\n\t\t\t\t\ttotal: downloadBodySize\n\t\t\t\t});\n\n\t\t\t\tcallback();\n\t\t\t}\n\t\t});\n\t},\n\n\tupload(request, emitter, uploadBodySize) {\n\t\tconst uploadEventFrequency = 150;\n\t\tlet uploaded = 0;\n\t\tlet progressInterval;\n\n\t\temitter.emit('uploadProgress', {\n\t\t\tpercent: 0,\n\t\t\ttransferred: 0,\n\t\t\ttotal: uploadBodySize\n\t\t});\n\n\t\trequest.once('error', () => {\n\t\t\tclearInterval(progressInterval);\n\t\t});\n\n\t\trequest.once('response', () => {\n\t\t\tclearInterval(progressInterval);\n\n\t\t\temitter.emit('uploadProgress', {\n\t\t\t\tpercent: 1,\n\t\t\t\ttransferred: uploaded,\n\t\t\t\ttotal: uploadBodySize\n\t\t\t});\n\t\t});\n\n\t\trequest.once('socket', socket => {\n\t\t\tconst onSocketConnect = () => {\n\t\t\t\tprogressInterval = setInterval(() => {\n\t\t\t\t\tconst lastUploaded = uploaded;\n\t\t\t\t\t/* istanbul ignore next: see #490 (occurs randomly!) */\n\t\t\t\t\tconst headersSize = request._header ? Buffer.byteLength(request._header) : 0;\n\t\t\t\t\tuploaded = socket.bytesWritten - headersSize;\n\n\t\t\t\t\t// Don't emit events with unchanged progress and\n\t\t\t\t\t// prevent last event from being emitted, because\n\t\t\t\t\t// it's emitted when `response` is emitted\n\t\t\t\t\tif (uploaded === lastUploaded || uploaded === uploadBodySize) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\temitter.emit('uploadProgress', {\n\t\t\t\t\t\tpercent: uploadBodySize ? uploaded / uploadBodySize : 0,\n\t\t\t\t\t\ttransferred: uploaded,\n\t\t\t\t\t\ttotal: uploadBodySize\n\t\t\t\t\t});\n\t\t\t\t}, uploadEventFrequency);\n\t\t\t};\n\n\t\t\t/* istanbul ignore next: hard to test */\n\t\t\tif (socket.connecting) {\n\t\t\t\tsocket.once('connect', onSocketConnect);\n\t\t\t} else if (socket.writable) {\n\t\t\t\t// The socket is being reused from pool,\n\t\t\t\t// so the connect event will not be emitted\n\t\t\t\tonSocketConnect();\n\t\t\t}\n\t\t});\n\t}\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}