{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { SeriesContext } from '../context/SeriesContextProvider';\nimport { CartesianContext } from '../context/CartesianContextProvider';\nimport { BarElement } from './BarElement';\nimport { isBandScaleConfig } from '../models/axis';\n\n/**\n * Solution of the equations\n * W = barWidth * N + offset * (N-1)\n * offset / (offset + barWidth) = r\n * @param bandWidth The width available to place bars.\n * @param numberOfGroups The number of bars to place in that space.\n * @param gapRatio The ratio of the gap between bars over the bar width.\n * @returns The bar width and the offset between bars.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction getBandSize({\n  bandWidth: W,\n  numberOfGroups: N,\n  gapRatio: r\n}) {\n  if (r === 0) {\n    return {\n      barWidth: W / N,\n      offset: 0\n    };\n  }\n  const barWidth = W / (N + (N - 1) * r);\n  const offset = r * barWidth;\n  return {\n    barWidth,\n    offset\n  };\n}\nfunction BarPlot(props) {\n  const seriesData = React.useContext(SeriesContext).bar;\n  const axisData = React.useContext(CartesianContext);\n  if (seriesData === undefined) {\n    return null;\n  }\n  const {\n    series,\n    stackingGroups\n  } = seriesData;\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = axisData;\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  return /*#__PURE__*/_jsx(React.Fragment, {\n    children: stackingGroups.flatMap(({\n      ids: groupIds\n    }, groupIndex) => {\n      return groupIds.flatMap(seriesId => {\n        var _series$seriesId$xAxi, _series$seriesId$yAxi;\n        const xAxisKey = (_series$seriesId$xAxi = series[seriesId].xAxisKey) != null ? _series$seriesId$xAxi : defaultXAxisId;\n        const yAxisKey = (_series$seriesId$yAxi = series[seriesId].yAxisKey) != null ? _series$seriesId$yAxi : defaultYAxisId;\n        const xAxisConfig = xAxis[xAxisKey];\n        const yAxisConfig = yAxis[yAxisKey];\n        const verticalLayout = series[seriesId].layout === 'vertical';\n        let baseScaleConfig;\n        if (verticalLayout) {\n          if (!isBandScaleConfig(xAxisConfig)) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud be of type \"band\" to display the bar series of id \"${seriesId}\"`);\n          }\n          if (xAxis[xAxisKey].data === undefined) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud have data property`);\n          }\n          baseScaleConfig = xAxisConfig;\n        } else {\n          if (!isBandScaleConfig(yAxisConfig)) {\n            throw new Error(`Axis with id \"${yAxisKey}\" shoud be of type \"band\" to display the bar series of id \"${seriesId}\"`);\n          }\n          if (yAxis[yAxisKey].data === undefined) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud have data property`);\n          }\n          baseScaleConfig = yAxisConfig;\n        }\n        const xScale = xAxisConfig.scale;\n        const yScale = yAxisConfig.scale;\n        const bandWidth = baseScaleConfig.scale.bandwidth();\n        const {\n          barWidth,\n          offset\n        } = getBandSize({\n          bandWidth,\n          numberOfGroups: stackingGroups.length,\n          gapRatio: baseScaleConfig.barGapRatio\n        });\n        const barOffset = groupIndex * (barWidth + offset);\n        const {\n          stackedData,\n          color\n        } = series[seriesId];\n        return stackedData.map((values, dataIndex) => {\n          var _xAxis$xAxisKey$data, _yAxis$yAxisKey$data;\n          const baseline = Math.min(...values);\n          const value = Math.max(...values);\n          return /*#__PURE__*/_jsx(BarElement, _extends({\n            id: seriesId,\n            dataIndex: dataIndex,\n            x: verticalLayout ? xScale((_xAxis$xAxisKey$data = xAxis[xAxisKey].data) == null ? void 0 : _xAxis$xAxisKey$data[dataIndex]) + barOffset : xScale(baseline),\n            y: verticalLayout ? yScale(value) : yScale((_yAxis$yAxisKey$data = yAxis[yAxisKey].data) == null ? void 0 : _yAxis$yAxisKey$data[dataIndex]) + barOffset,\n            height: verticalLayout ? Math.abs(yScale(baseline) - yScale(value)) : barWidth,\n            width: verticalLayout ? barWidth : Math.abs(xScale(baseline) - xScale(value)),\n            color: color,\n            highlightScope: series[seriesId].highlightScope\n          }, props), `${seriesId}-${dataIndex}`);\n        });\n      });\n    })\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? BarPlot.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * The props used for each component slot.\n   * @default {}\n   */\n  slotProps: PropTypes.object,\n  /**\n   * Overridable component slots.\n   * @default {}\n   */\n  slots: PropTypes.object\n} : void 0;\nexport { BarPlot };","map":{"version":3,"names":["_extends","React","PropTypes","SeriesContext","CartesianContext","BarElement","isBandScaleConfig","jsx","_jsx","getBandSize","bandWidth","W","numberOfGroups","N","gapRatio","r","barWidth","offset","BarPlot","props","seriesData","useContext","bar","axisData","undefined","series","stackingGroups","xAxis","yAxis","xAxisIds","yAxisIds","defaultXAxisId","defaultYAxisId","Fragment","children","flatMap","ids","groupIds","groupIndex","seriesId","_series$seriesId$xAxi","_series$seriesId$yAxi","xAxisKey","yAxisKey","xAxisConfig","yAxisConfig","verticalLayout","layout","baseScaleConfig","Error","data","xScale","scale","yScale","bandwidth","length","barGapRatio","barOffset","stackedData","color","map","values","dataIndex","_xAxis$xAxisKey$data","_yAxis$yAxisKey$data","baseline","Math","min","value","max","id","x","y","height","abs","width","highlightScope","process","env","NODE_ENV","propTypes","slotProps","object","slots"],"sources":["/home/amfarwati/Documents/SPOC_Analyse_Impact_IT/v_0.0/client/node_modules/@mui/x-charts/esm/BarChart/BarPlot.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { SeriesContext } from '../context/SeriesContextProvider';\nimport { CartesianContext } from '../context/CartesianContextProvider';\nimport { BarElement } from './BarElement';\nimport { isBandScaleConfig } from '../models/axis';\n\n/**\n * Solution of the equations\n * W = barWidth * N + offset * (N-1)\n * offset / (offset + barWidth) = r\n * @param bandWidth The width available to place bars.\n * @param numberOfGroups The number of bars to place in that space.\n * @param gapRatio The ratio of the gap between bars over the bar width.\n * @returns The bar width and the offset between bars.\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction getBandSize({\n  bandWidth: W,\n  numberOfGroups: N,\n  gapRatio: r\n}) {\n  if (r === 0) {\n    return {\n      barWidth: W / N,\n      offset: 0\n    };\n  }\n  const barWidth = W / (N + (N - 1) * r);\n  const offset = r * barWidth;\n  return {\n    barWidth,\n    offset\n  };\n}\nfunction BarPlot(props) {\n  const seriesData = React.useContext(SeriesContext).bar;\n  const axisData = React.useContext(CartesianContext);\n  if (seriesData === undefined) {\n    return null;\n  }\n  const {\n    series,\n    stackingGroups\n  } = seriesData;\n  const {\n    xAxis,\n    yAxis,\n    xAxisIds,\n    yAxisIds\n  } = axisData;\n  const defaultXAxisId = xAxisIds[0];\n  const defaultYAxisId = yAxisIds[0];\n  return /*#__PURE__*/_jsx(React.Fragment, {\n    children: stackingGroups.flatMap(({\n      ids: groupIds\n    }, groupIndex) => {\n      return groupIds.flatMap(seriesId => {\n        var _series$seriesId$xAxi, _series$seriesId$yAxi;\n        const xAxisKey = (_series$seriesId$xAxi = series[seriesId].xAxisKey) != null ? _series$seriesId$xAxi : defaultXAxisId;\n        const yAxisKey = (_series$seriesId$yAxi = series[seriesId].yAxisKey) != null ? _series$seriesId$yAxi : defaultYAxisId;\n        const xAxisConfig = xAxis[xAxisKey];\n        const yAxisConfig = yAxis[yAxisKey];\n        const verticalLayout = series[seriesId].layout === 'vertical';\n        let baseScaleConfig;\n        if (verticalLayout) {\n          if (!isBandScaleConfig(xAxisConfig)) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud be of type \"band\" to display the bar series of id \"${seriesId}\"`);\n          }\n          if (xAxis[xAxisKey].data === undefined) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud have data property`);\n          }\n          baseScaleConfig = xAxisConfig;\n        } else {\n          if (!isBandScaleConfig(yAxisConfig)) {\n            throw new Error(`Axis with id \"${yAxisKey}\" shoud be of type \"band\" to display the bar series of id \"${seriesId}\"`);\n          }\n          if (yAxis[yAxisKey].data === undefined) {\n            throw new Error(`Axis with id \"${xAxisKey}\" shoud have data property`);\n          }\n          baseScaleConfig = yAxisConfig;\n        }\n        const xScale = xAxisConfig.scale;\n        const yScale = yAxisConfig.scale;\n        const bandWidth = baseScaleConfig.scale.bandwidth();\n        const {\n          barWidth,\n          offset\n        } = getBandSize({\n          bandWidth,\n          numberOfGroups: stackingGroups.length,\n          gapRatio: baseScaleConfig.barGapRatio\n        });\n        const barOffset = groupIndex * (barWidth + offset);\n        const {\n          stackedData,\n          color\n        } = series[seriesId];\n        return stackedData.map((values, dataIndex) => {\n          var _xAxis$xAxisKey$data, _yAxis$yAxisKey$data;\n          const baseline = Math.min(...values);\n          const value = Math.max(...values);\n          return /*#__PURE__*/_jsx(BarElement, _extends({\n            id: seriesId,\n            dataIndex: dataIndex,\n            x: verticalLayout ? xScale((_xAxis$xAxisKey$data = xAxis[xAxisKey].data) == null ? void 0 : _xAxis$xAxisKey$data[dataIndex]) + barOffset : xScale(baseline),\n            y: verticalLayout ? yScale(value) : yScale((_yAxis$yAxisKey$data = yAxis[yAxisKey].data) == null ? void 0 : _yAxis$yAxisKey$data[dataIndex]) + barOffset,\n            height: verticalLayout ? Math.abs(yScale(baseline) - yScale(value)) : barWidth,\n            width: verticalLayout ? barWidth : Math.abs(xScale(baseline) - xScale(value)),\n            color: color,\n            highlightScope: series[seriesId].highlightScope\n          }, props), `${seriesId}-${dataIndex}`);\n        });\n      });\n    })\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? BarPlot.propTypes = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // | To update them edit the TypeScript types and run \"yarn proptypes\"  |\n  // ----------------------------------------------------------------------\n  /**\n   * The props used for each component slot.\n   * @default {}\n   */\n  slotProps: PropTypes.object,\n  /**\n   * Overridable component slots.\n   * @default {}\n   */\n  slots: PropTypes.object\n} : void 0;\nexport { BarPlot };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}