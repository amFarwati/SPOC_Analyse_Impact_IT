import _extends from "@babel/runtime/helpers/esm/extends";
import * as React from 'react';
import { useSlotProps } from '@mui/base/utils';
import { unstable_composeClasses as composeClasses } from '@mui/utils';
import { useThemeProps, useTheme, styled } from '@mui/material/styles';
import { DrawingContext } from '../context/DrawingProvider';
import { getSeriesToDisplay } from './utils';
import { SeriesContext } from '../context/SeriesContextProvider';
import { getChartsLegendUtilityClass } from './chartsLegendClasses';
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
const useUtilityClasses = ownerState => {
  const {
    classes,
    direction
  } = ownerState;
  const slots = {
    root: ['root', direction],
    mark: ['mark'],
    label: ['label'],
    series: ['series']
  };
  return composeClasses(slots, getChartsLegendUtilityClass, classes);
};
function getTranslePosition({
  position,
  drawingArea
}) {
  let xValue;
  switch (position.horizontal) {
    case 'left':
      xValue = `calc(var(--ChartsLegend-rootOffsetX, 0px) + ${drawingArea.left}px - var(--ChartsLegend-rootWidth))`;
      break;
    case 'middle':
      xValue = `calc(var(--ChartsLegend-rootOffsetX, 0px) + ${drawingArea.left + drawingArea.width / 2}px - 0.5 * var(--ChartsLegend-rootWidth))`;
      break;
    default:
      xValue = `calc(var(--ChartsLegend-rootOffsetX, 0px) + ${drawingArea.left + drawingArea.width}px)`;
      break;
  }
  let yValue;
  switch (position.vertical) {
    case 'top':
      yValue = `calc(var(--ChartsLegend-rootOffsetY, 0px) + ${drawingArea.top}px - var(--ChartsLegend-rootHeight))`;
      break;
    case 'middle':
      yValue = `calc(var(--ChartsLegend-rootOffsetY, 0px) + ${drawingArea.top + drawingArea.height / 2}px - 0.5 * var(--ChartsLegend-rootHeight))`;
      break;
    default:
      yValue = `calc(var(--ChartsLegend-rootOffsetY, 0px) + ${drawingArea.top + drawingArea.height}px)`;
      break;
  }
  return {
    transform: `translate(${xValue}, ${yValue})`
  };
}
export const ChartsLegendRoot = styled('g', {
  name: 'MuiChartsLegend',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})(({
  ownerState
}) => {
  const {
    direction,
    drawingArea,
    offsetX,
    offsetY,
    seriesNumber,
    position
  } = ownerState;
  return _extends({
    '--ChartsLegend-rootOffsetX': typeof offsetX === 'number' ? `${offsetX}px` : undefined,
    '--ChartsLegend-rootOffsetY': typeof offsetY === 'number' ? `${offsetY}px` : undefined,
    '--ChartsLegend-rootWidth': direction === 'row' ? `calc(var(--ChartsLegend-itemWidth) * ${seriesNumber} + var(--ChartsLegend-rootSpacing) * ${seriesNumber - 1} )` : 'var(--ChartsLegend-itemWidth)',
    '--ChartsLegend-rootHeight': direction === 'row' ? 'var(--ChartsLegend-itemMarkSize)' : `calc(var(--ChartsLegend-itemMarkSize) * ${seriesNumber} + var(--ChartsLegend-rootSpacing) * ${seriesNumber - 1} )`
  }, getTranslePosition({
    position,
    drawingArea,
    offsetX,
    offsetY
  }));
});
export const ChartsSeriesLegendGroup = styled('g', {
  name: 'MuiChartsLegend',
  slot: 'ChartsSeriesLegendGroup',
  overridesResolver: (props, styles) => styles.series
})(({
  ownerState
}) => {
  const {
    direction,
    seriesIndex
  } = ownerState;
  if (direction === 'row') {
    return {
      transform: `translate(calc(${seriesIndex} * (var(--ChartsLegend-itemWidth) + var(--ChartsLegend-rootSpacing))), 0)`
    };
  }
  return {
    transform: `translate(0, calc(${seriesIndex} * (var(--ChartsLegend-itemMarkSize) + var(--ChartsLegend-rootSpacing))))`
  };
});
export const ChartsLegendMark = styled('rect', {
  name: 'MuiChartsLegend',
  slot: 'Mark',
  overridesResolver: (props, styles) => styles.mark
})(({
  ownerState
}) => ({
  x: 0,
  y: 0,
  width: 'var(--ChartsLegend-itemMarkSize)',
  height: 'var(--ChartsLegend-itemMarkSize)',
  fill: ownerState.color
}));
export const ChartsLegendLabel = styled('text', {
  name: 'MuiChartsLegend',
  slot: 'Label',
  overridesResolver: (props, styles) => styles.label
})(({
  theme
}) => _extends({}, theme.typography.body1, {
  color: 'inherit',
  transform: `translate(
      calc(var(--ChartsLegend-itemMarkSize) + var(--ChartsLegend-labelSpacing)),
      calc(0.5 * var(--ChartsLegend-itemMarkSize))
      )`,
  fill: theme.palette.text.primary,
  dominantBaseline: 'central'
}));
const defaultProps = {
  position: {
    horizontal: 'middle',
    vertical: 'top'
  },
  direction: 'row',
  markSize: 20,
  itemWidth: 100,
  spacing: 2
};
function DefaultChartsLegend(props) {
  const {
    hidden,
    position,
    direction,
    offset,
    series,
    seriesToDisplay,
    drawingArea,
    classes
  } = props;
  if (hidden) {
    return null;
  }
  return /*#__PURE__*/_jsx(ChartsLegendRoot, {
    ownerState: {
      direction,
      offsetX: offset?.x,
      offsetY: offset?.y,
      seriesNumber: seriesToDisplay.length,
      position,
      drawingArea
    },
    className: classes.root,
    children: seriesToDisplay.map(({
      id,
      label,
      color
    }, seriesIndex) => /*#__PURE__*/_jsxs(ChartsSeriesLegendGroup, {
      ownerState: _extends({
        direction,
        seriesIndex
      }, series),
      className: classes.series,
      children: [/*#__PURE__*/_jsx(ChartsLegendMark, {
        ownerState: {
          color
        },
        className: classes.mark
      }), /*#__PURE__*/_jsx(ChartsLegendLabel, {
        className: classes.label,
        children: label
      })]
    }, id))
  });
}
export function ChartsLegend(inProps) {
  const props = useThemeProps({
    props: _extends({}, defaultProps, inProps),
    name: 'MuiChartsLegend'
  });
  const {
    position,
    direction,
    offset,
    hidden,
    slots,
    slotProps
  } = props;
  const theme = useTheme();
  const classes = useUtilityClasses(_extends({}, props, {
    theme
  }));
  const drawingArea = React.useContext(DrawingContext);
  const series = React.useContext(SeriesContext);
  const seriesToDisplay = getSeriesToDisplay(series);
  const ChartLegendRender = slots?.legend ?? DefaultChartsLegend;
  const chartLegendRenderProps = useSlotProps({
    elementType: ChartLegendRender,
    externalSlotProps: slotProps?.legend,
    additionalProps: {
      position,
      direction,
      offset,
      classes,
      drawingArea,
      series,
      hidden,
      seriesToDisplay
    },
    ownerState: {}
  });
  return /*#__PURE__*/_jsx(ChartLegendRender, _extends({}, chartLegendRenderProps));
}