"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChartsLegend = ChartsLegend;
exports.ChartsSeriesLegendGroup = exports.ChartsLegendRoot = exports.ChartsLegendMark = exports.ChartsLegendLabel = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var React = _interopRequireWildcard(require("react"));
var _utils = require("@mui/base/utils");
var _utils2 = require("@mui/utils");
var _styles = require("@mui/material/styles");
var _DrawingProvider = require("../context/DrawingProvider");
var _utils3 = require("./utils");
var _SeriesContextProvider = require("../context/SeriesContextProvider");
var _chartsLegendClasses = require("./chartsLegendClasses");
var _jsxRuntime = require("react/jsx-runtime");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const useUtilityClasses = ownerState => {
  const {
    classes,
    direction
  } = ownerState;
  const slots = {
    root: ['root', direction],
    mark: ['mark'],
    label: ['label'],
    series: ['series']
  };
  return (0, _utils2.unstable_composeClasses)(slots, _chartsLegendClasses.getChartsLegendUtilityClass, classes);
};
function getTranslePosition({
  position,
  drawingArea
}) {
  let xValue;
  switch (position.horizontal) {
    case 'left':
      xValue = `calc(var(--ChartsLegend-rootOffsetX, 0px) + ${drawingArea.left}px - var(--ChartsLegend-rootWidth))`;
      break;
    case 'middle':
      xValue = `calc(var(--ChartsLegend-rootOffsetX, 0px) + ${drawingArea.left + drawingArea.width / 2}px - 0.5 * var(--ChartsLegend-rootWidth))`;
      break;
    default:
      xValue = `calc(var(--ChartsLegend-rootOffsetX, 0px) + ${drawingArea.left + drawingArea.width}px)`;
      break;
  }
  let yValue;
  switch (position.vertical) {
    case 'top':
      yValue = `calc(var(--ChartsLegend-rootOffsetY, 0px) + ${drawingArea.top}px - var(--ChartsLegend-rootHeight))`;
      break;
    case 'middle':
      yValue = `calc(var(--ChartsLegend-rootOffsetY, 0px) + ${drawingArea.top + drawingArea.height / 2}px - 0.5 * var(--ChartsLegend-rootHeight))`;
      break;
    default:
      yValue = `calc(var(--ChartsLegend-rootOffsetY, 0px) + ${drawingArea.top + drawingArea.height}px)`;
      break;
  }
  return {
    transform: `translate(${xValue}, ${yValue})`
  };
}
const ChartsLegendRoot = (0, _styles.styled)('g', {
  name: 'MuiChartsLegend',
  slot: 'Root',
  overridesResolver: (props, styles) => styles.root
})(({
  ownerState
}) => {
  const {
    direction,
    drawingArea,
    offsetX,
    offsetY,
    seriesNumber,
    position
  } = ownerState;
  return (0, _extends2.default)({
    '--ChartsLegend-rootOffsetX': typeof offsetX === 'number' ? `${offsetX}px` : undefined,
    '--ChartsLegend-rootOffsetY': typeof offsetY === 'number' ? `${offsetY}px` : undefined,
    '--ChartsLegend-rootWidth': direction === 'row' ? `calc(var(--ChartsLegend-itemWidth) * ${seriesNumber} + var(--ChartsLegend-rootSpacing) * ${seriesNumber - 1} )` : 'var(--ChartsLegend-itemWidth)',
    '--ChartsLegend-rootHeight': direction === 'row' ? 'var(--ChartsLegend-itemMarkSize)' : `calc(var(--ChartsLegend-itemMarkSize) * ${seriesNumber} + var(--ChartsLegend-rootSpacing) * ${seriesNumber - 1} )`
  }, getTranslePosition({
    position,
    drawingArea,
    offsetX,
    offsetY
  }));
});
exports.ChartsLegendRoot = ChartsLegendRoot;
const ChartsSeriesLegendGroup = (0, _styles.styled)('g', {
  name: 'MuiChartsLegend',
  slot: 'ChartsSeriesLegendGroup',
  overridesResolver: (props, styles) => styles.series
})(({
  ownerState
}) => {
  const {
    direction,
    seriesIndex
  } = ownerState;
  if (direction === 'row') {
    return {
      transform: `translate(calc(${seriesIndex} * (var(--ChartsLegend-itemWidth) + var(--ChartsLegend-rootSpacing))), 0)`
    };
  }
  return {
    transform: `translate(0, calc(${seriesIndex} * (var(--ChartsLegend-itemMarkSize) + var(--ChartsLegend-rootSpacing))))`
  };
});
exports.ChartsSeriesLegendGroup = ChartsSeriesLegendGroup;
const ChartsLegendMark = (0, _styles.styled)('rect', {
  name: 'MuiChartsLegend',
  slot: 'Mark',
  overridesResolver: (props, styles) => styles.mark
})(({
  ownerState
}) => ({
  x: 0,
  y: 0,
  width: 'var(--ChartsLegend-itemMarkSize)',
  height: 'var(--ChartsLegend-itemMarkSize)',
  fill: ownerState.color
}));
exports.ChartsLegendMark = ChartsLegendMark;
const ChartsLegendLabel = (0, _styles.styled)('text', {
  name: 'MuiChartsLegend',
  slot: 'Label',
  overridesResolver: (props, styles) => styles.label
})(({
  theme
}) => (0, _extends2.default)({}, theme.typography.body1, {
  color: 'inherit',
  transform: `translate(
      calc(var(--ChartsLegend-itemMarkSize) + var(--ChartsLegend-labelSpacing)),
      calc(0.5 * var(--ChartsLegend-itemMarkSize))
      )`,
  fill: theme.palette.text.primary,
  dominantBaseline: 'central'
}));
exports.ChartsLegendLabel = ChartsLegendLabel;
const defaultProps = {
  position: {
    horizontal: 'middle',
    vertical: 'top'
  },
  direction: 'row',
  markSize: 20,
  itemWidth: 100,
  spacing: 2
};
function DefaultChartsLegend(props) {
  const {
    hidden,
    position,
    direction,
    offset,
    series,
    seriesToDisplay,
    drawingArea,
    classes
  } = props;
  if (hidden) {
    return null;
  }
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(ChartsLegendRoot, {
    ownerState: {
      direction,
      offsetX: offset?.x,
      offsetY: offset?.y,
      seriesNumber: seriesToDisplay.length,
      position,
      drawingArea
    },
    className: classes.root,
    children: seriesToDisplay.map(({
      id,
      label,
      color
    }, seriesIndex) => /*#__PURE__*/(0, _jsxRuntime.jsxs)(ChartsSeriesLegendGroup, {
      ownerState: (0, _extends2.default)({
        direction,
        seriesIndex
      }, series),
      className: classes.series,
      children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(ChartsLegendMark, {
        ownerState: {
          color
        },
        className: classes.mark
      }), /*#__PURE__*/(0, _jsxRuntime.jsx)(ChartsLegendLabel, {
        className: classes.label,
        children: label
      })]
    }, id))
  });
}
function ChartsLegend(inProps) {
  const props = (0, _styles.useThemeProps)({
    props: (0, _extends2.default)({}, defaultProps, inProps),
    name: 'MuiChartsLegend'
  });
  const {
    position,
    direction,
    offset,
    hidden,
    slots,
    slotProps
  } = props;
  const theme = (0, _styles.useTheme)();
  const classes = useUtilityClasses((0, _extends2.default)({}, props, {
    theme
  }));
  const drawingArea = React.useContext(_DrawingProvider.DrawingContext);
  const series = React.useContext(_SeriesContextProvider.SeriesContext);
  const seriesToDisplay = (0, _utils3.getSeriesToDisplay)(series);
  const ChartLegendRender = slots?.legend ?? DefaultChartsLegend;
  const chartLegendRenderProps = (0, _utils.useSlotProps)({
    elementType: ChartLegendRender,
    externalSlotProps: slotProps?.legend,
    additionalProps: {
      position,
      direction,
      offset,
      classes,
      drawingArea,
      series,
      hidden,
      seriesToDisplay
    },
    ownerState: {}
  });
  return /*#__PURE__*/(0, _jsxRuntime.jsx)(ChartLegendRender, (0, _extends2.default)({}, chartLegendRenderProps));
}